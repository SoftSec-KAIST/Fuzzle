#!/usr/bin/env bash
# smake -- generates analysis rules from make rules
# Author: Jaeho Shin <netj@ropas.snu.ac.kr>
# Created: 2006-01-11
AnalyzerId=sparrow
Revision=r1045
CCHooks=(gcc g++ cc c++ clang clang++ cpp as ld ar wllvm)
Hooks=(rm mv cp ln)

AMAKEDIRpath=$AnalyzerId
which realpath > /dev/null
if [[ $? == 1 ]]; then
    realpath="readlink -f"
else
    realpath="realpath"
fi
Base="`$realpath "$0"`"
Base="`dirname "$Base"`"
Base=`cd "$Base" && pwd || echo "$Base"`

set -e

realpath() {
    case "$1" in
        /*) echo "$1" ;;
        *)  echo "$PWD/$1" ;;
    esac
}

main() {
case "$1" in
## usage
--help)
cat <<EOF
smake $Revision
  a program analysis preparation tool for C programs made with GNU Make

smake observes the build process driven by make(1), and derives the
standalone, preprocessed form of the source code that makes up each
C program linked during the process.  smake creates a directory
"$AMAKEDIRpath/", where you can perform program analyses with make(1).

You can instantly start your program analysis in three steps:
 1. Initialize "$AMAKEDIRpath/", i.e. \$AMAKEDIR.
 2. Use \`smake\` instead of \`make\` to build your programs.
 3. Use \`make\` under \$AMAKEDIR to analyze your programs.

Usage:
 $ smake --init [<options>]
  initializes $AMAKEDIRpath/ to handle the regular use of smake.
  If you use a special compiler (e.g. cross compiler), its type must be
  specified by appending gcc style options, e.g. \`-b mips-linux -V 2.95\`.

 $ smake --clean
  completely removes $AMAKEDIRpath/.

 $ smake <parameters for make>
  runs \`make [<with parameters>]\` and bookkeeps \$AMAKEDIR.

 $ smake ./configure
  runs \`./configure\` under the same environment \`smake\` runs.

 $ smake --help
  shows this message.

EOF
;;

## initialize $AMAKEDIR
--init) shift
if [ -n "$AMAKEDIR" ]; then
    # if AMAKEDIR is specified
    dir=$AMAKEDIR
else
    # otherwise, use default
    # detect and warn the presence of $AMAKEDIRpath in parents( of parents)*?
    find_AMAKEDIR && confirm "smake: $AMAKEDIR/ exists, override it? "
    # use default
    AMAKEDIR="$PWD/$AMAKEDIRpath"
    dir=$AMAKEDIRpath
fi
#[ -d "$AMAKEDIR" ] && abort "smake: $dir/ exists!  You cannot initialize twice."
AMAKEROOT=$PWD
HookBase="$AMAKEDIR/.bin"
# create $AMAKEDIR and the Makefile for analysis
AnalyzerPath=`realpath "$0"`
mkdir -p "$AMAKEDIR"
cd "$AMAKEDIR"
cat >Makefile <<EOF
# Makefile for analyzing programs made with Makefiles under:
#  $AMAKEROOT
#
# Generated at `now`
#           by smake($Revision) --init $@.

ANALYZE?=`dirname "$AnalyzerPath"`/$AnalyzerId
TGTS=\$(shell cat .targets | sed -e 's/\$\$/.$AnalyzerId/')

ifneq (\$(origin STEST),undefined)
export OPTS=-uidebug
export REDIRECTION=2>&1 | tee \$@.log
endif

.PHONY: help banner targets all clean update
help: banner targets
banner:
	@\$(ANALYZE) | sed -ne '1,/^\$\$/p'

\$(TGTS):
	\$(ANALYZE) \$(SPARROW_OPTS) \$(OPTS) -report=\$@ \$(@:%.$AnalyzerId=%)/* \$(REDIRECTION)

targets:
	@echo "Following <target>s are ready to be analyzed:"
	@for p in \$(TGTS); do echo "  \$\$p"; done
	@echo
	@echo "Run 'make all' to analyze everything,"
	@echo "or you may specify the targets as 'make <target> ...'."

all: \$(TGTS)
clean:
	rm -rf \$(TGTS)
EOF

touch .targets
ln -sf "$AMAKEROOT" .root
#  setup HookBase
mkdir -p "$HookBase"
hooks "$@" | while read; do
    # symlink to the hook with command names we want to monitor
    ln -sf "$Base/hook" "$HookBase/$REPLY"
done
#  log file
{
    echo "### Generated by smake($Revision) --init $@"
    echo "###           at `now`"
} >.smake.log
;;

## clean up
--clean)
if [ -n "$AMAKEDIR" ]; then
    # if AMAKEDIR is specified
    dir=$AMAKEDIR
else
    # otherwise, use default
    AMAKEDIR="$PWD/$AMAKEDIRpath"
    dir=$AMAKEDIRpath
fi
# check if AMAKEDIR exists
[ -d "$AMAKEDIR" ] || abort "smake: It is clean here, there is no $dir/."
echo -n "smake: Cleaning up... "
rm -rf "$AMAKEDIR"
echo "Removed $dir/."
;;

## ./configure with the same $PATH make will be run
./configure)
must_be_initialized
PATH="$HookBase:$PATH" \
run "$@"
;;

## follow make rules
*)
must_be_initialized
AMAKECONFIGURE=false \
PATH="$HookBase:$PATH" \
run make "$@"
;;
esac
}

now() { LC_ALL=C date +"%c %z"; }

abort() {
    echo "$@"
    exit 2
}

confirm() {
    echo -n "$@"
    read
    case "$REPLY" in
        [Yy])   true    ;;
        *)      false   ;;
    esac
}

run() {
    local signals="ERR INT HUP QUIT TERM"
    {
        echo
        echo "## Running $@"
        echo "## Started at `now`"
    } >>"$AMAKEDIR/.smake.log"
    log_error() {
        local exitcode=$?
        trap "" $signals
        echo "## Aborted with exit code $exitcode at `now`" >>"$AMAKEDIR/.smake.log"
        exit $?
    }
    trap log_error $signals
    "$@"
    echo "## Finished at `now`" >>"$AMAKEDIR/.smake.log"
    echo "smake: recorded activities in $AMAKEDIR/."
}

# find a parent who has $AMAKEDIRpath and set AMAKEDIR, AMAKEROOT
find_AMAKEDIR() {
    local dir=$PWD
    # look upwards, find the directory that has $AMAKEDIRpath
    until [ -e "$dir/$AMAKEDIRpath/.smake.log" -o "${dir:-/}" = / ]; do
        dir=`cd "$dir"/.. && pwd || echo /`
    done
    if [ -d "$dir/$AMAKEDIRpath" ]; then
        # set variables if found
        AMAKEDIR=`cd "$dir" && cd "$AMAKEDIRpath" && pwd`
        AMAKEROOT=`readlink "$AMAKEDIR/.root" || echo "$dir"`
        export AMAKEDIR AMAKEROOT
        HookBase="$AMAKEDIR/.bin"
        true
    else
        false
    fi
}

must_be_initialized() {
    if [ -d "$AMAKEDIR" ] || find_AMAKEDIR; then
        true
    else
        $0 --help
        echo "smake: No \$AMAKEDIR found.  Run \`smake --init\` first."
        exit 2
    fi
}

hooks() {
    local machine= version= o
    while getopts "b:V:" o; do
        case "$o" in
            b) machine=$OPTARG ;;
            V) version=$OPTARG ;;
        esac
    done
    local h
    # compiler suites
    for h in "${CCHooks[@]}"; do
        echo "${machine:+$machine-}$h${version:+-$version}"
    done
    # common utilities
    for h in "${Hooks[@]}"; do
        echo "$h"
    done
}

prefix() {
	local h=$1; shift
    local machine= version= o
    while getopts "b:V:" o; do
        case "$o" in
            b) machine=$OPTARG ;;
            V) version=$OPTARG ;;
        esac
    done
    echo "${machine:+$machine-}$h${version:+-$version}"
}

main "$@"
